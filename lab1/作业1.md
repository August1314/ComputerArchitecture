计算机体系结构 作业1

计算机体系结构 作业1

背景介绍 · 文件说明 · 实验步骤

- 1.部署 gem5 模拟器
- 2.编译提供的 `daxpy.cpp` 为 RISC-V 二进制文件
- 3.使用提供的 `O3CPU.py` 仿真配置文件，模拟 RISC-V 架构的 O3 CPU 运行上一步得到的二进制文件
- 4.编写实验报告 · 作业提交要求

附录

- 1 在虚拟机中部署 gem5
  - 1.1 编译环境准备
  - 1.2 编译项目
- 2 使用 Docker 容器部署 gem5
  - 2.1 确认虚拟化已开启
  - 2.2 安装 WSL
  - 2.3 安装 Docker
  - 2.4 下载 Docker 镜像
  - 2.5 在 VS Code 中安装 Dev Containers 插件
  - 2.6 启动 Docker 容器
  - 2.7 在 Dev Containers 中连接容器
  - 2.8 使用 SCons 构建 gem5
- 3 在 WSL 中部署 gem5


在本次作业中，你将尝试使用 gem5 进行一个基于 Tomasulo 算法实现的乱序 CPU（O3 CPU）仿真实验：在本地机器上编译部署 gem5，将一份 C++ 代码编译为 RISC-V 二进制文件，然后使用 gem5 O3 CPU 模拟运行该二进制文件，调整 O3 CPU 几个关键参数并观察分析对系统性能的影响。
背景介绍
1.gem5




gem5 模拟器是一个用于计算机系统体系结构研究的模块化仿真平台。gem5 最初是为学术界的计算机体系结构研究而设计的，但如今它的应用已日益广泛，被学术界和工业界用于研究和计算机系统设计，并应用于教学领域。
gem5 官网：`https://www.gem5.org/`
2.O3 CPU

在理论课中，我们学习了 Tomasulo 算法，它揭示了现代高性能处理器通过乱序执行（Out-of-Order，OoO）来挖掘指令级并行性的核心思想。本次作业我们尝试使用的是 gem5 中实现的 O3 CPU，参考现实中的 Alpha 21264 处理器架构（不完全一致），其设计思想同样基于 Tomasulo 算法——通过寄存器重命名来消除数据伪依赖，并利用一个大的指令窗口来动态地寻找并执行那些操作数已就绪的指令，从而最大限度地挖掘程序中的指令级并行性，不过在实现上与我们学习的经典 Tomasulo 存在一些差异，例如重命名方式、流水线阶段划分、部件设置等。

注意：这里的 O3 指 Out-of-Order，而不是编译器优化等级。
O3CPU中的关键部件

1. ROB（Reorder Buffer，重排序缓冲）：与经典 Tomasulo 算法中的 ROB 功能基本一致，用于实现指令的按序提交和精确异常。
2. IQ（Instruction Queue，指令队列）：O3 CPU 中的指令在 Rename 阶段结束后，除了在 ROB 中创建相应条目，也会在 IQ 中创建相应条目。IQ 的作用类似经典 Tomasulo 算法中的保留站：在 Tomasulo 中每个功能部件拥有一个专属的保留站，而在 O3 CPU 中所有功能部件共享一个“保留站”，即为 IQ（除了 load/store 指令有专门的 Load/Store Queue，LSQ）。
3. 物理寄存器堆：这是实现 O3 CPU 中寄存器重命名的前提。O3 CPU 内部拥有远多于 ISA 逻辑寄存器的物理寄存器，在流水线中的重命名阶段，O3 CPU 为指令中的逻辑寄存器分配物理寄存器。如果物理寄存器堆耗尽，O3 CPU 流水线中的重命名阶段将阻塞。
O3 CPU的流水线阶段划分
O3 CPU 实现了一个五阶段流水线：

1. 取指（Fetch）：每个周期获取指令，并进行分支预测。
2. 译码（Decode）：每个周期解码指令，并提前处理无条件分支指令。
3. 重命名（Rename）：使用带空闲列表的物理寄存器堆为逻辑寄存器分配物理寄存器（算法见 `resources/DynamicScheduling` 介绍 PDF），从而消除伪依赖。完成重命名后，为指令分配 ROB/IQ 条目，进入乱序阶段（Rename + Dispatch）。与经典 Tomasulo 不同，O3 CPU 使用单独阶段进行寄存器重命名。
4. 发射/执行/写回（Issue/Execute/Writeback - IEW）：在操作数就绪后进行发射、读取、执行与写回。所需时钟数视操作数准备与指令类型而定，可能从 1 到数百个周期不等。
5. 提交（Commit）：按序提交已完成的指令，并处理故障与分支预测错误。
除了上述介绍，如果想要对O3 CPU有更彻底的了解，可以查看下面给出的参考资料，里面有对O3 CPU更细致的讲解。


参考资料

- gem5 O3 CPU 介绍：`https://www.gem5.org/documentation/general_docs/cpu_models/O3CPU`
- `resources` 目录下的 DynamicScheduling 介绍 PDF


文件说明

- `O3CPU.py`：O3 CPU 的仿真配置脚本
- `daxpy.cpp`：要仿真运行的程序源代码
- `resources/`：帮助理解 gem5/O3 CPU 的学习资料

实验步骤

1. 部署 gem5 模拟器（Linux 环境）。可选环境：虚拟机（VMware、VirtualBox）、Docker、WSL（附录提供参考）。
   - 官方部署教程参考：gem5: Building gem5
   - 在 gem5 根目录运行 hello world 测试程序验证安装成功。

2. 编译提供的 `daxpy.cpp` 为 RISC-V 二进制文件。
   - 安装交叉编译工具（示例：`gcc-riscv64-linux-gnu`、`g++-riscv64-linux-gnu`）。
   - 使用交叉编译器生成 RISC-V 可执行文件。

3. 使用提供的 `O3CPU.py` 仿真配置文件，模拟 RISC-V 架构的 O3 CPU 运行上一步得到的二进制文件。
   - 需要在不同参数组合下获取仿真结果。参数说明如下：

   | 参数名称 | 说明 | 取值范围 |
   | --- | --- | --- |
   | `--num-phys-int-regs` | 物理整数寄存器数目 | 64, 256, 1024 |
   | `--num-iq-entries` | IQ 条目数 | 4, 16, 64, 256 |
   | `--num-rob-entries` | ROB 条目数 | 4, 16, 64, 256 |

   - 仿真运行命令可通过修改上述参数的取值进行多次实验。
   - 仿真结果会保存至 `--outdir` 指定目录下的 `stats.txt` 中。

   - 在 `stats.txt` 中查找 CPU 仿真的性能指标，建议关注：

   | 指标名称 | 说明 |
   | --- | --- |
   | `system.cpu.numCycles` | CPU 模拟运行的总时钟数 |
   | `system.cpu.rename.ROBFullEvents` | 由于 ROB 已满导致的重命名阶段堵塞 |
   | `system.cpu.rename.IQFullEvents` | 由于 IQ 已满导致的重命名阶段堵塞 |
   | `system.cpu.rename.fullRegistersEvents` | 由于物理寄存器耗尽导致的重命名阶段堵塞 |

你至少需要完成以下内容：

- 遍历参数组合进行仿真实验，记录每次仿真的 `system.cpu.numCycles`，并以表格或可视化图表呈现。
  - 提示：可编写自动化脚本减少手工操作。
- 基于仿真数据，分析 IQ 条目数与 ROB 条目数对总时钟数的影响：随着这两个参数增大，总时钟数如何变化？存在何种瓶颈？原因何在？
  - 提示：可参考 Tomasulo 算法进行分析。

选做（加分）：

- （5 分）分析物理整数寄存器数目对 O3 CPU 性能的影响。无限制增大该数目是否存在性能瓶颈？为什么？
  - 提示：阅读 `resources` 目录下 DynamicScheduling（重命名相关）与 `daxpy.cpp`。
- （5 分）尝试修改 `O3CPU.py` 中的其他设置，分析其对仿真性能的影响。

4. 编写实验报告

- 形式不限。需包含：
  - 实验过程介绍与关键步骤（gem5 部署验证、`daxpy.cpp` 编译、仿真启动/结束等）的截图与命令记录。如有额外代码，请附上并简述用途。
  - 完成实验步骤 3 中的实验内容与分析。

作业提交要求

1. 请提交 PDF 版本的实验报告，命名为“[姓名]-[学号]-lab1.pdf”，例如“张三-23000001-lab1.pdf”。如需提交代码，与报告一同打包为 zip，命名为“[姓名]-[学号]-lab1.zip”。
2. 作业提交至超算习堂。
3. 截止时间（DDL）：10.26 23:59。

附录

1 在虚拟机中部署 gem5

- 提示：最终项目文件大小约 6G，`-j 2` 情况下编译过程所需内存约 7G，请预留足够空间。

1.1 编译环境准备

- 使用 VMware Workstation（或 VirtualBox）。安装可参考相关教程。
- Ubuntu 镜像网站选择所需版本；示例使用 22.04.5。安装完成后在命令行查看版本号。
- 拉取仓库代码。

1.2 编译项目

- 参考官方文档：gem5 构建官方教程。
- 在 Ubuntu 22.04 上安装 gem5 编译与运行依赖。
- 若虚拟机内存 4G，建议编译时用 `-j 1`；8G 可用 `-j 2`。
- 编译过程约需 2 小时。
- 完成后可继续编译 `.cpp` 文件并调整仿真配置完成实验。
- 可能需要安装：`sudo apt install gcc-riscv64-linux-gnu g++-riscv64-linux-gnu`。

2 使用 Docker 容器部署 gem5

- Docker 安装参考教程。

2.1 确认虚拟化已开启

- Docker 依赖虚拟化。检查 BIOS 中是否启用虚拟化。
- Windows 检查：Ctrl+Shift+Esc → 性能 → 右下角“虚拟化”。

2.2 安装 WSL

- 管理员命令提示符执行：`wsl --install`。

2.3 安装 Docker

- 安装 Docker Desktop。

2.4 下载 Docker 镜像

- 参考链接：`https://github.com/gem5/gem5/pkgs/container/ubuntu-24.04_all-dependencies`

2.5 在 VS Code 中安装 Dev Containers 插件

2.6 启动 Docker 容器

- 参数解析：
  - 数据卷挂载（volume mount）：左边 `[lab1 directory]`（Windows 主机目录）→ 右边 `/lab1`（容器目录）。
  - 指定要运行的 Docker 镜像。
  - 挂载后，容器内看到的即为 Windows 目录内容，修改实时同步。

2.7 在 Dev Containers 中连接容器

- 使用插件连接运行中的容器。

2.8 使用 SCons 构建 gem5

- 在容器内克隆 gem5 仓库（建议在容器内直接 clone）。
- 在 gem5 根目录执行构建。构建约需 2 小时。

3 在 WSL 中部署 gem5

- 参考教程：
  - `https://learn.microsoft.com/zh-cn/windows/wsl/install`
  - `https://blog.csdn.net/x777777x/article/details/141092913`
  - `https://learn.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-vscode`
- 在 Windows 终端执行命令并按提示完成 WSL 安装。
- 通过 VS Code 远程连接 WSL：
  - 安装 VS Code：`https://code.visualstudio.com/`
  - 安装相关插件，点击左下角蓝色按钮选择 “Connect to WSL”。
- 连接后可像本地一样浏览 WSL 文件与目录。
- WSL 中部署 gem5 与虚拟机/容器类似，通过命令行进行。可在 VS Code 中打开终端。
- 之后步骤与虚拟机部署方法一致。